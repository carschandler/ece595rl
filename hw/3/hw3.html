<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Robert (Cars) Chandler — chandl71@purdue.edu">

<title>ECE59500RL HW3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="hw4_files/libs/clipboard/clipboard.min.js"></script>
<script src="hw4_files/libs/quarto-html/quarto.js"></script>
<script src="hw4_files/libs/quarto-html/popper.min.js"></script>
<script src="hw4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="hw4_files/libs/quarto-html/anchor.min.js"></script>
<link href="hw4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="hw4_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="hw4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="hw4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="hw4_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="hw4.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ECE59500RL HW3</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Robert (Cars) Chandler — chandl71@purdue.edu </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="problem-1" class="level2">
<h2 class="anchored" data-anchor-id="problem-1">Problem 1</h2>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section">1.1</h3>
<p>Using the definition of the state-action occupancy measure under a stationary, stochastic policy:</p>
<p><span class="math display">\[
\nu_{\mu_{0}}^{\pi}(s,a) = \sum_{t=0}^{\infty}\gamma^{t}\mathbb{P}(S_{t}=s, A_{t}=a | \mu_{0}, \pi, P)
\]</span></p>
<p>The state-action occupancy measure takes a state and action pair and calculates the total (discounted) probability that the state and action at any time are that state and action. If we sum this across all actions, then we are really just finding the discounted probability that the state is that current state for all timesteps.</p>
<p>What we are saying below is the probability of the first state being the state in the parameter plus the sum of the probability of transitioning from some state-action combo to the state in question times the total probability across all steps of that state-action combo, across all state-action combos.</p>
<p>$$ <em>{a } </em>{_{0}}^{}(s,a) =</p>
<p><em>{0}(s) + </em>{s’ } <em>{a’ } P(s | s’, a’) ^{}</em>{_{0}}(s’,a’) $$ If we sum over all actions:</p>
<p><span class="math display">\[
\sum_{a \in \mathcal{A}} \nu_{\mu_{0}}^{\pi}(s,a) = \sum_{a \in \mathcal{A}} \sum_{t=0}^{\infty}\gamma^{t}\mathbb{P}(S_{t}=s, A_{t}=a | \mu_{0}, \pi, P)
\]</span></p>
<p>Then we can drop the <span class="math inline">\(A_{t} = a\)</span> part since sum of the probability of a state-action pair across all possible actions will marginalize out the action on the probability measurement. From there, we can pull out the first term in the sum, marginalize the resulting probability inside the sum across all possible states and actions of the previous timestep, rearrange our sums, and realize that we have another state-action occupancy measure defined:</p>
<p>$$ <span class="math display">\[\begin{align}

\sum_{a \in \mathcal{A}} \nu_{\mu_{0}}^{\pi}(s,a) &amp;= \sum_{a \in \mathcal{A}} \sum_{t=0}^{\infty}\gamma^{t}\mathbb{P}(S_{t}=s, A_{t}=a | \mu_{0}, \pi, P) \\

&amp;= \sum_{t=0}^{\infty} \gamma^{t}\mathbb{P}(S_{t}=s | \mu_{0}, \pi, P) \\

&amp;= \gamma^{0} \mathbb{P} (S_{0} = s | \mu_{0}, \pi, P) + \sum_{t=1}^{\infty}\gamma^{t}\mathbb{P}(S_{t}=s | \mu_{0}, \pi, P) \\

&amp;= \mu_{0}(s) +  \sum_{t=1}^{\infty}\gamma^{t}\mathbb{P}(S_{t}=s | \mu_{0}, \pi, P) \\

&amp;= \mu_{0}(s) +  \sum_{t=1}^{\infty}\gamma^{t} \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} \mathbb{P}(S_{t}=s, S_{t-1} = s', A_{t-1} = a' | \mu_{0}, \pi, P) \\

&amp;= \mu_{0}(s) +  \sum_{t=1}^{\infty}\gamma^{t} \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} \mathbb{P}(S_{t}=s | S_{t-1} = s', A_{t-1} = a',  \mu_{0}, \pi, P)  \cdot \mathbb{P}\left( S_{t-1}=s', A_{t-1}=a' | \mu_{0}, \pi, P \right) \\

&amp;= \mu_{0}(s) +  \sum_{t=1}^{\infty}\gamma^{t} \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \cdot \mathbb{P}\left( S_{t-1}=s', A_{t-1}=a' | \mu_{0}, \pi, P \right) \\

&amp;= \mu_{0}(s) +  \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \cdot \sum_{t=1}^{\infty}\gamma^{t} \mathbb{P}\left( S_{t-1}=s', A_{t-1}=a' | \mu_{0}, \pi, P \right) \\

&amp;= \mu_{0}(s) +  \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \cdot \sum_{t=0}^{\infty}\gamma^{t+1} \mathbb{P}\left( S_{t}=s', A_{t}=a' | \mu_{0}, \pi, P \right) \\

&amp;= \mu_{0}(s) +  \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \cdot \gamma\sum_{t=0}^{\infty}\gamma^{t} \mathbb{P}\left( S_{t}=s', A_{t}=a' | \mu_{0}, \pi, P \right) \\

&amp;= \mu_{0}(s) +  \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \cdot \gamma \nu^{\pi}_{\mu_{0}}(s', a') \\

&amp;= \mu_{0}(s) + \gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \nu^{\pi}_{\mu_{0}}(s', a') &amp; \blacksquare \\

\end{align}\]</span> $$</p>
</section>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1">1.2</h3>
<p>Given the definition of the state occupancy measure: <span class="math display">\[
\rho_{\mu_{0}}^{\pi}(s) = \sum_{t=0}^{\infty} \gamma^{t} \mathbb{P}(S_{t} = s| \mu_{0}, \pi, P)
\]</span> We can marginalize the probability over all actions in <span class="math inline">\(\mathcal{A}\)</span> and rearrange the order of the summation:</p>
<p>$$ <span class="math display">\[\begin{align}

\rho_{\mu_{0}}^{\pi}(s) &amp;= \sum_{t=0}^{\infty} \gamma^{t} \mathbb{P}(S_{t} = s| \mu_{0}, \pi, P) \\

&amp;= \sum_{t=0}^{\infty} \gamma^{t} \mathbb{P}(S_{t} = s| \mu_{0}, \pi, P) \\

&amp;= \sum_{t=0}^{\infty} \gamma^{t} \sum_{a \in \mathcal{A}} \mathbb{P}(S_{t} = s, A_{t} = a| \mu_{0}, \pi, P) \\

&amp;= \sum_{a \in \mathcal{A}} \sum_{t=0}^{\infty} \gamma^{t}  \mathbb{P}(S_{t} = s, A_{t} = a| \mu_{0}, \pi, P) \\

\rho_{\mu_{0}}^{\pi}(s) &amp;= \sum_{a \in \mathcal{A}} \nu_{\mu_{0}}^{\pi}(s,a) &amp; \blacksquare \\

\end{align}\]</span> $$</p>
<p>Given the definition of the state-action occupancy measure, we can use the definition of conditional probability to construct a product of two probabilities, substitute in the policy function using its definition, and finally use the definition of the state occupancy measure: $$ <span class="math display">\[\begin{align}

\nu_{\mu_{0}}^{\pi}(s,a) &amp;= \sum_{t=0}^{\infty} \gamma^{t}  \mathbb{P}(S_{t} = s, A_{t} = a| \mu_{0}, \pi, P) \\

&amp;= \sum_{t=0}^{\infty} \gamma^{t}  \mathbb{P}(S_{t} = s | \mu_{0}, \pi, P) \mathbb{P}(A_{t} = a | S_{t} = s, \mu_{0}, \pi, P) \\

&amp;= \sum_{t=0}^{\infty} \gamma^{t}  \mathbb{P}(S_{t} = s | \mu_{0}, \pi, P) \pi(a|s) \\

\nu_{\mu_{0}}^{\pi}(s,a) &amp;= \rho_{\mu_{0}}^{\pi}(s) \pi(a|s) &amp; \blacksquare \\

\end{align}\]</span> $$</p>
</section>
<section id="section-2" class="level3">
<h3 class="anchored" data-anchor-id="section-2">1.3</h3>
<p>We just showed in <a href="#section-1">1.2</a> that <span class="math display">\[
\rho_{\mu_{0}}^{\pi}(s) = \sum_{a \in \mathcal{A}} \nu_{\mu_{0}}^{\pi}(s,a)
\]</span> And in <a href="#section">1.1</a> that</p>
<p><span class="math display">\[
\sum_{a \in \mathcal{A}} \nu_{\mu_{0}}^{\pi}(s,a) = \mu_{0}(s) + \gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \nu^{\pi}_{\mu_{0}}(s', a')
\]</span> So by the transitive property: <span class="math display">\[
\rho_{\mu_{0}}^{\pi}(s) = \mu_{0}(s) + \gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \nu^{\pi}_{\mu_{0}}(s', a')
\]</span> To convert this into vector form, the first <span class="math inline">\(\mu_{0}\)</span> term in the sum is easy to take care of as it is added separately, so we can just form the equivalent vector: <span class="math display">\[
\mathbf{\mu_{0}} = \begin{bmatrix}
\mu_{0}(s_{1})  \\
\mu_{0}(s_{2})  \\
\vdots \\
\mu_{0}(s_{\lvert \mathcal{S} \rvert })  \\
\end{bmatrix}
\]</span></p>
<p>Next, we need the sum across all states and actions of the product of the transition function with the state-action occupancy measure. However, the transition function for each iteration of the summation needs to be evaluated for the state-action pair given by the summation transitioning to the state corresponding to the current index in the resulting vector. The state-action occupancy measure needs to be evaluated for the current state-action pair given by the summation. We also showed in <a href="#section-1">1.2</a> that</p>
<p><span class="math display">\[
\nu_{\mu_{0}}^{\pi}(s,a) = \rho_{\mu_{0}}^{\pi}(s) \pi(a|s)
\]</span></p>
<p>So the summation term in question can be rewritten as:</p>
<p><span class="math display">\[
\gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} P(s | s', a') \rho_{\mu_{0}}^{\pi}(s') \pi(a'|s')
\]</span></p>
<p>If we rewrite the <span class="math inline">\(P\)</span> and <span class="math inline">\(\pi\)</span> terms in terms of the probabilities they express and expand these probabilities using the definition of conditional probability, we get:</p>
<p>$$ <span class="math display">\[\begin{align}
&amp;\gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} \mathbb{P}(S_{t}=s | S_{t-1}=s', A_{t-1}=a') \mathbb{P}(A_{t-1} = a' | S_{t-1}=s') \rho_{\mu_{0}}^{\pi}(s') \\

&amp;= \gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} \frac{\mathbb{P}(S_{t}=s , S_{t-1}=s', A_{t-1}=a')}{\mathbb{P}(S_{t-1}=s', A_{t-1}=a')}  \frac{\mathbb{P}(A_{t-1} = a' , S_{t-1}=s')}{\mathbb{P}(S_{t-1}=s')} \rho_{\mu_{0}}^{\pi}(s') \\

&amp;= \gamma \sum_{s' \in \mathcal{S}} \sum_{a' \in \mathcal{A}} \frac{\mathbb{P}(S_{t}=s , S_{t-1}=s', A_{t-1}=a')}{\mathbb{P}(S_{t-1}=s')} \rho_{\mu_{0}}^{\pi}(s') \\

&amp;= \gamma \sum_{s' \in \mathcal{S}} \rho_{\mu_{0}}^{\pi}(s') \sum_{a' \in \mathcal{A}} \frac{\mathbb{P}(S_{t}=s , S_{t-1}=s', A_{t-1}=a')}{\mathbb{P}(S_{t-1}=s')} \\

&amp;= \gamma \sum_{s' \in \mathcal{S}} \rho_{\mu_{0}}^{\pi}(s') \frac{\mathbb{P}(S_{t}=s , S_{t-1}=s')}{\mathbb{P}(S_{t-1}=s')} \\

&amp;= \gamma \sum_{s' \in \mathcal{S}} \rho_{\mu_{0}}^{\pi}(s') \mathbb{P}(S_{t}=s | S_{t-1}=s') \\

&amp;= \gamma \sum_{s' \in \mathcal{S}} \rho_{\mu_{0}}^{\pi}(s') P(s | s') \\

\end{align}\]</span> $$</p>
<p>And we can create this sum using matrix multiplication. Since <span class="math inline">\(\mathbf{P}^{\pi}_{ij} = P(s_{j} | s_{i})\)</span>, this means that a single column of <span class="math inline">\(\mathbf{P}^{\pi}\)</span> corresponds to the different states <span class="math inline">\(s'\)</span> could be. Standard matrix multiplication of <span class="math inline">\(\mathbf{P}^{\pi}\)</span> against some column vector would multiply rows against the vector, though. So, if we want to multiply the columns to achieve a summation of the product of <span class="math inline">\(P(s|s')\)</span> with <span class="math inline">\(\rho_{\mu_{0}}^{\pi}(s')\)</span> across <span class="math inline">\(s' \in \mathcal{S}\)</span> rather than <span class="math inline">\(s \in \mathcal{S}\)</span>, we need to transpose <span class="math inline">\(\mathbf{P}^{\pi}\)</span> first and then matrix-multiply it against <span class="math inline">\(\mathbf{\rho_{\mu_{0}}}^{\pi}\)</span>:</p>
<p>$$ <span class="math display">\[\begin{align}

\gamma \sum_{s' \in \mathcal{S}} \rho_{\mu_{0}}^{\pi}(s') P(s | s') &amp;=  \gamma \begin{bmatrix}
P^{\pi}(s_{1} | s_{1}) &amp; P^{\pi}(s_{2} | s_{1}) &amp; \cdots &amp; P^{\pi}(s_{\lvert \mathcal{S} \rvert } | s_{1}) \\
P^{\pi}(s_{1} | s_{2}) &amp; P^{\pi}(s_{2} | s_{2}) &amp; \cdots &amp; P^{\pi}(s_{\lvert \mathcal{S} \rvert } | s_{2}) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
P^{\pi}(s_{1} | s_{|\mathcal{S}|}) &amp; P^{\pi}(s_{2} | s_{|\mathcal{S}|}) &amp; \cdots &amp; P^{\pi}(s_{\lvert \mathcal{S} \rvert } | s_{|\mathcal{S}|}) \\
\end{bmatrix}^{T}
\begin{bmatrix}
\rho^{\pi}_{\mu_{0}}(s_{1}) \\
\rho^{\pi}_{\mu_{0}}(s_{2}) \\
\vdots \\
\rho^{\pi}_{\mu_{0}}(s_{\lvert \mathcal{S} \rvert }) \\
\end{bmatrix} \\

&amp;= \gamma {\mathbf{P}^{\pi}}^{T} \mathbf{\rho^{\pi}_{\mu_{0}}}

\end{align}\]</span> $$</p>
<p>So finally, substituting this into the original sum:</p>
<p><span class="math display">\[
\mathbf{\rho_{\mu_{0}}^{\pi}} = \mathbf{\mu_{0} } + \gamma {\mathbf{P}^{\pi}}^{T} \mathbf{\rho^{\pi}_{\mu_{0}}}
\]</span></p>
</section>
<section id="section-3" class="level3">
<h3 class="anchored" data-anchor-id="section-3">1.4</h3>
<p>$$ <span class="math display">\[\begin{align}

\mathbf{\rho_{\mu_{0}}^{\pi}} &amp;= \mathbf{\mu_{0} } + \gamma {\mathbf{P}^{\pi}}^{T} \mathbf{\rho^{\pi}_{\mu_{0}}}  \\

\mathbf{\rho_{\mu_{0}}^{\pi}} - \gamma {\mathbf{P}^{\pi}}^{T} \mathbf{\rho^{\pi}_{\mu_{0}}} &amp;= \mathbf{\mu_{0} } \\

\left( \mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T} \right) \mathbf{\rho_{\mu_{0}}^{\pi}}  &amp;= \mathbf{\mu_{0} } \\

\mathbf{\rho_{\mu_{0}}^{\pi}}  &amp;=  \left( \mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T} \right)^{-1} \mathbf{\mu_{0} } \\

\end{align}\]</span> $$</p>
<p>The inverted quantity in the final line takes on the same form as the quantity proven to be invertible in Problem 1 of Homework 2: <span class="math inline">\(\mathbf{I} - \gamma \mathbf{P}^{\pi}\)</span>. As a reminder, this quantity was shown to be invertible by an analysis of the eigenvalues. We showed that all the eigenvalues of <span class="math inline">\(\mathbf{P}^{\pi}\)</span> were nonzero by considering a theoretical eigenvalue to be greater than <span class="math inline">\(1\)</span>, which then proved to be impossible. From there, we showed that the eigenvalues of the entire quantity would necessarily be nonzero, proving that the quantity was invertible.</p>
<p>Now, if <span class="math inline">\((\mathbf{I} - \gamma \mathbf{P}^{\pi})\)</span> is invertible, then so is <span class="math inline">\((\mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T})\)</span> since a matrix and its transpose always have the same eigenvalues, so the same argument applies to prove that this quantity is invertible.</p>
<p>To say that <span class="math inline">\((\mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T})\)</span> is invertible is to say that the equation <span class="math inline">\(\mathbf{x} (\mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T}) = \mathbf{b}\)</span> has a unique for <span class="math inline">\(\mathbf{x}\)</span> given some arbitrary <span class="math inline">\(\mathbf{b}\)</span>. To show this, consider some matrix <span class="math inline">\(\mathbf{A}\)</span> that is invertible:</p>
<p><span class="math display">\[
\begin{align}
\mathbf{Ax} &amp;= \mathbf{b}  \\
\mathbf{A}^{-1} \mathbf{Ax} &amp;= \mathbf{A}^{-1} \mathbf{b} \\
\mathbf{Ix} &amp;= \mathbf{A}^{-1} \mathbf{b} \\
\mathbf{x} &amp;= \mathbf{A}^{-1} \mathbf{b} \\
\end{align}
\]</span></p>
<p><span class="math inline">\(\mathbf{A}^{-1}\mathbf{b}\)</span> always yields a single vector, which is the unique solution to the equation. Our equation</p>
<p><span class="math display">\[
\left( \mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T} \right) \mathbf{\rho_{\mu_{0}}^{\pi}} = \mathbf{\mu_{0} }
\]</span> takes on this exact form, such that <span class="math display">\[
\mathbf{\rho_{\mu_{0}}^{\pi}} =  \left( \mathbf{I} - \gamma {\mathbf{P}^{\pi}}^{T} \right)^{-1} \mathbf{\mu_{0} }
\]</span></p>
<p>is the unique solution to <span class="math inline">\(\rho_{\mu_{0}}^{\pi}\)</span>.</p>
</section>
<section id="section-4" class="level3">
<h3 class="anchored" data-anchor-id="section-4">1.5</h3>
<p>Using the definition of <span class="math inline">\(\nu_{\mu_{0}}^{\pi}\)</span> from <a href="#section-1">1.2</a>, we can rearrange to solve for <span class="math inline">\(\pi\)</span>, then substitute in the definition of <span class="math inline">\(\rho_{\mu_{0}}^{\pi}(s)\)</span> from <a href="#section-1">1.2</a>:</p>
<p>$$ <span class="math display">\[\begin{align}
\nu_{\mu_{0}}^{\pi}(s,a) &amp;= \rho_{\mu_{0}}^{\pi}(s) \pi(a|s) \\

\pi(a|s)  &amp;= \frac{\nu_{\mu_{0}}^{\pi}(s,a) }{\rho_{\mu_{0}}^{\pi}(s)} \\

\pi(a|s)  &amp;= \frac{\nu_{\mu_{0}}^{\pi}(s,a) }{\sum_{a' \in \mathcal{A}} \nu_{\mu_{0}}^{\pi}(s,a')} \\
\end{align}\]</span> $$</p>
<p>This is the first part of the piecewise equation.</p>
</section>
</section>
<section id="todo-is-there-more-to-do-here" class="level1">
<h1>TODO: is there more to do here?</h1>
<section id="section-5" class="level2">
<h2 class="anchored" data-anchor-id="section-5">1.6</h2>
<p>It is given that</p>
<p><span class="math display">\[
V^{\pi}(\mu) = \mathbb{E}_{S \sim \mu}\left[ V^{\pi}(S) \right]  = \sum_{s \in \mathcal{S}} \mu(s) V^{\pi}(s)
\]</span></p>
<p>So, substituting in <span class="math inline">\(\mu_{0}\)</span>:</p>
<p>$$ <span class="math display">\[\begin{align}

V^{\pi}(\mu_{0}) &amp;= \mathbb{E}_{S \sim \mu_{0}}\left[ V^{\pi}(S) \right]  = \sum_{s \in \mathcal{S}} \mu_{0}(s) V^{\pi}(s) \\

V^{\pi}(\mu_{0}) &amp;= \sum_{s \in \mathcal{S}} \mu_{0}(s) \mathbb{E} \left[  \sum_{t=0}^{\infty} \gamma^t R(s_t, a_t) | s_0 = s \right] \\

V^{\pi}(\mu_{0}) &amp;= \sum_{s \in \mathcal{S}} \mathbb{P}(s_{0} = s) \sum_{a \in \mathcal{A}} \sum_{s \in \mathcal{S}} \left[ \mathbb{P}(s_{0} = s | s_{0} = s) \mathbb{P}(A_{0} = a | s_{0} = s) \sum_{t=0}^{\infty} \gamma^t R(s_t, a_t) \right] \\

V^{\pi}(\mu_{0}) &amp;= \sum_{s \in \mathcal{S}} \mathbb{P}(s_{0} = s) \sum_{a \in \mathcal{A}} \sum_{s \in \mathcal{S}} \left[ 1 \cdot \pi(a|s) \sum_{t=0}^{\infty} \gamma^t R(s_t, a_t) | s_0 = s \right] \\


\end{align}\]</span> $$</p>
<p><span class="math display">\[
v^{\pi}(s) = \mathbb{E} \left[
\sum_{t=0}^{\infty} \gamma^t R(s_t, a_t) | s_0 = s \right], \quad \forall s \in
\mathcal{S}
\]</span></p>
</section>
<section id="problem-2" class="level2">
<h2 class="anchored" data-anchor-id="problem-2">Problem 2</h2>
<section id="section-6" class="level3">
<h3 class="anchored" data-anchor-id="section-6">2.1</h3>
<p>If <span class="math inline">\(\left| R(s,a) \right| \le R_{max}\)</span> and</p>
<p><span class="math display">\[
G_{i}^{s} = \sum_{t=0}^{\left| \tau_{i}^{s} \right| } \gamma^{t}R(S^{s}_{t,i}, S^{s}_{t,i})
\]</span></p>
<p>then in the case where <span class="math inline">\(R\)</span> is greatest, i.e.&nbsp;<span class="math inline">\(R = R_{max}\)</span>,</p>
<p><span class="math display">\[
G_{i}^{s} = \sum_{t=0}^{\left| \tau_{i}^{s} \right| } \gamma^{t} R_{max} = \frac{R_{max}}{1 - \gamma}
\]</span> and in the case where <span class="math inline">\(R\)</span> is least, i.e.&nbsp;<span class="math inline">\(R=-R_{max}\)</span>,</p>
<p><span class="math display">\[
G_{i}^{s} = \sum_{t=0}^{\left| \tau_{i}^{s} \right| } -\gamma^{t} R_{max} = -\frac{R_{max}}{1 - \gamma}
\]</span> Therefore:</p>
<p><span class="math display">\[
- \frac{R_{max}}{1-\gamma} \le G_{i}^{s} \le \frac{R_{max}}{1 -\gamma}
\]</span></p>
</section>
<section id="section-7" class="level3">
<h3 class="anchored" data-anchor-id="section-7">2.2</h3>
<p><span class="math display">\[
E(s) = \sum_{i=1}^{N^{s}}G_{i}^{s}
\]</span> <span class="math display">\[
\begin{align}
\mathbb{E}_{A_{t \sim \pi}, S_{t+1} \sim P}[E(s)] &amp;= \mathbb{E}_{A_{t \sim \pi}, S_{t+1} \sim P} \left[ \sum_{i=1}^{N^{s}} G_{i}^{s} \right] \\
&amp;= \sum_{i=1}^{N^{s}} \mathbb{E}_{A_{t \sim \pi}, S_{t+1} \sim P} \left[  G_{i}^{s} \right] \\
&amp;= \sum_{i=1}^{N^{s}} V^{\pi}(s) \\
\end{align}
\]</span></p>
</section>
<section id="section-8" class="level3">
<h3 class="anchored" data-anchor-id="section-8">2.3</h3>
</section>
</section>
</section>
<section id="todo-do-we-need-to-prove-that-the-inequality-holds-with-probability-1" class="level1">
<h1>TODO: do we need to prove that the inequality holds with probability 1?</h1>
<p>Since we were able to bound <span class="math inline">\(G_{i}^{s}\)</span> on both sides, and since <span class="math inline">\(E(s)\)</span> is a sum of that bound variable, we can apply Hoeffding’s inequality to bound the probability that <span class="math inline">\(E(s)\)</span> deviates from its expected value. Let <span class="math inline">\(s_{N^{s}} = E(s) = \sum_{i=1}^{N^{s}}G_{i}^{s}\)</span> be the sum used in the inequality:</p>
<p><span class="math display">\[
\mathbb{P}\left( \left| E(s) - \mathbb{E}[E(s)] \right| \ge \varepsilon \right) \le 2 \exp \left( -\frac{2\varepsilon^{2}}{\sum_{i=1}^{N^{s}} \left( \frac{2R_{max}}{1-\gamma} \right)^{2} } \right) = 2 \exp \left( -\frac{\varepsilon^{2}}{\sum_{i=1}^{N^{s}} 2\left( \frac{R_{max}}{1-\gamma} \right)^{2} } \right)
\]</span></p>
<section id="section-9" class="level3">
<h3 class="anchored" data-anchor-id="section-9">2.4</h3>
<p>We can apply the corrolary to Hoeffding’s inequality which allows us to bound the arithmetic mean of the summed term:</p>
<p><span class="math display">\[
\mathbb{P}\left(\left| \bar{s}_{t} - E[\bar{s}_{t}] \ge \varepsilon  \right| \right) \le 2 \exp \left( \frac{-2 \varepsilon^{2}t}{(b_{i} - a_{i})^{2}} \right), \quad \forall \varepsilon \ge 0
\]</span></p>
<p>If <span class="math inline">\(s_{N^{s}}\)</span> was the sum in the previous step, then</p>
<p><span class="math display">\[
\bar{s}_{i} = \frac{1}{N^{s}}\sum_{i=1}^{N^{s}} G_{i}^{s} = \hat{V}^{\pi}(s)
\]</span></p>
<p>And then the expected value of <span class="math inline">\(\bar{s}_{N^{s}}\)</span> is:</p>
<p><span class="math display">\[
\mathbb{E} \left[ \frac{1}{N^{s}}\sum_{i=1}^{N^{s}} G_{i}^{s} \right] = \frac{1}{N^{s}}\sum_{i=1}^{N^{s}} \mathbb{E} \left[  G_{i}^{s} \right] = \frac{1}{N^{s}}\sum_{i=1}^{N^{s}} V^{\pi}(s) = \frac{1}{N^{s}} N^{s} V^{\pi}(s) = V^{\pi}(s)
\]</span></p>
<p>So we have <span class="math inline">\(\bar{s}_{i}\)</span> and <span class="math inline">\(\mathbb{E}[\bar{s}_{i}]\)</span> to use in the alternate form of Hoeffding’s inequality:</p>
<p><span class="math display">\[
\mathbb{P}\left(\left| \hat{V}^{\pi}(s) - V^{\pi}(s) \right| \ge \varepsilon'\right) \le 2 \exp \left( -\frac{ 2(\varepsilon')^{2}N^{s}}{\left( \frac{2R_{max}}{1-\gamma} \right)^{2}} \right) = 2 \exp \left( -\frac{ (\varepsilon')^{2}N^{s}}{2 \left( \frac{R_{max}}{1-\gamma} \right)^{2}} \right), \quad \forall \varepsilon' \ge 0
\]</span></p>
</section>
<section id="section-10" class="level3">
<h3 class="anchored" data-anchor-id="section-10">2.5</h3>
<p>As <span class="math inline">\(N^{s}\)</span> decreases, the term inside the exponential in <a href="#section-9">2.4</a> becomes less negative, so the exponential term itself becomes greater. Therefore, the smallest <span class="math inline">\(N^{s}\)</span> will yield the largest <span class="math inline">\(\mathbb{P}\left(\left| \hat{V}^{\pi}(s) - V^{\pi}(s) \right| \ge \varepsilon'\right)\)</span>. In other words, <span class="math inline">\(N\)</span> will yield the largest probability of all <span class="math inline">\(N^{s}\)</span>, so we can use it to bound <span class="math inline">\(\mathbb{P}\left( \lVert \hat{V}^{\pi} - V^{\pi} \rVert_{\infty} \ge \varepsilon'\right)\)</span>. We have already calculated the bound for the absolute difference any given state, and the L-<span class="math inline">\(\infty\)</span> norm will give us the maximum absolute difference across all states. We do not have a way to calculate which state will yield the maximum absolute difference, so we can instead calculate the total probability that the absolute difference will be greater than <span class="math inline">\(\varepsilon'\)</span> for <em>any</em> state, which is the union of all the events, which we can bound using Boole’s inequality:</p>
<p><span class="math display">\[
\mathbb{P}\left( \lVert \hat{V}^{\pi} - V^{\pi} \rVert_{\infty} \ge \varepsilon'\right) \le \mathbb{P} \left( \bigcup_{s \in \mathcal{S}} \left| \hat{V}^{\pi}(s) - V^{\pi}(s) \right| \ge \varepsilon' \right) \le \sum_{s \in \mathcal{S}} \mathbb{P}\left(\left| \hat{V}^{\pi}(s) - V^{\pi}(s) \right| \ge \varepsilon' \right)
\]</span></p>
<p>And we can bound this sum using the bound we determined in <a href="#section-9">2.4</a> since the sum of a bounded function must be less than or equal to the sum of its bound. We substitute <span class="math inline">\(N\)</span> in for <span class="math inline">\(N^{s}\)</span> since we already showed how it will yield the greatest value, which is desired to achieve an upper bound:</p>
<p><span class="math display">\[
\mathbb{P}\left( \lVert \hat{V}^{\pi} - V^{\pi} \rVert_{\infty} \ge \varepsilon'\right) \le \sum_{s \in \mathcal{S}} \mathbb{P}\left(\left| \hat{V}^{\pi}(s) - V^{\pi}(s) \right| \ge \varepsilon' \right) \le \sum_{i=1}^{\left| \mathcal{S} \right| } 2 \exp \left( -\frac{ (\varepsilon')^{2}N}{2 \left( \frac{R_{max}}{1-\gamma} \right)^{2}} \right)
\]</span> <span class="math display">\[
\sum_{i=1}^{\left| \mathcal{S} \right| } 2 \exp \left( -\frac{ (\varepsilon')^{2}N}{2 \left( \frac{R_{max}}{1-\gamma} \right)^{2}} \right) = 2 \left| S \right| \exp \left( -\frac{ (\varepsilon')^{2}N}{2 \left( \frac{R_{max}}{1-\gamma} \right)^{2}} \right)
\]</span></p>
<p>So finally:</p>
<p><span class="math display">\[
\mathbb{P}\left( \lVert \hat{V}^{\pi} - V^{\pi} \rVert_{\infty} \ge \varepsilon'\right) \le
2 \left| S \right| \exp \left( -\frac{ (\varepsilon')^{2}N}{2 \left( \frac{R_{max}}{1-\gamma} \right)^{2}} \right)
, \quad \forall \varepsilon' &gt; 0
\]</span></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>